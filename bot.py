import datetime
import pytz
import asyncio
from tinydb import TinyDB, Query
from telegram import Update, ReplyKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, ContextTypes, filters
from apscheduler.schedulers.background import BackgroundScheduler

TOKEN = "8087039975:AAHilkGMZAIwQtglfaeApBHDpcNREqlpCNE"
db = TinyDB("/data/db.json")
User = Query()

waiting_for_name = set()
waiting_for_gender = set()

keyboard = [
    ["–û–±—ñ–π–º–∏", "–°–∫–∞–∂–∏ —â–æ—Å—å –º–∏–ª–µ"],
    ["–°–∫—ñ–ª—å–∫–∏ –∑–∞—Ä–∞–∑ —á–∞—Å—É", "–ö–æ—Ç–∏–∫ üê±"],
    ["–ó–∞–ø–∏—à–∏ –º–æ—î —ñ–º'—è"]
]
reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)

def get_user(user_id):
    result = db.search(User.id == user_id)
    return result[0] if result else None

def save_user(user_id, name=None, gender=None):
    user = get_user(user_id)
    if user:
        update_data = {}
        if name:
            update_data["name"] = name
        if gender:
            update_data["gender"] = gender
        db.update(update_data, User.id == user_id)
    else:
        db.insert({"id": user_id, "name": name, "gender": gender, "todo": []})

def gendered(name, gender):
    if gender == "–∂":
        return name or "–∑–∞–π—á–∏—á–∫–æ"
    elif gender == "—á":
        return name or "–∑–∞–π—á–∏–∫—É"
    else:
        return name or "–∑–∞–π—á–∏–∫"

def gendered_phrase(gender, feminine: str, masculine: str, neutral: str = "—á—É–¥–æ–≤–∞(–∏–π)"):
    if gender == "–∂":
        return feminine
    elif gender == "—á":
        return masculine
    else:
        return neutral

def parse_date(text):
    today = datetime.date.today()
    weekdays = {
        "–ø–æ–Ω–µ–¥—ñ–ª–æ–∫": 0, "–≤—ñ–≤—Ç–æ—Ä–æ–∫": 1, "—Å–µ—Ä–µ–¥–∞": 2,
        "—á–µ—Ç–≤–µ—Ä": 3, "–ø º—è—Ç–Ω–∏—Ü—è": 4, "—Å—É–±–æ—Ç–∞": 5, "–Ω–µ–¥—ñ–ª—è": 6
    }
    text = text.strip().lower()
    if text == "—Å—å–æ–≥–æ–¥–Ω—ñ":
        return today.strftime("%Y-%m-%d")
    elif text == "–∑–∞–≤—Ç—Ä–∞":
        return (today + datetime.timedelta(days=1)).strftime("%Y-%m-%d")
    elif text in weekdays:
        current = today.weekday()
        target = weekdays[text]
        days_ahead = (target - current + 7) % 7 or 7
        return (today + datetime.timedelta(days=days_ahead)).strftime("%Y-%m-%d")
    else:
        try:
            return datetime.datetime.strptime(text, "%Y-%m-%d").strftime("%Y-%m-%d")
        except:
            return None

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("–ü—Ä–∏–≤ –∫—É! –û–±–µ—Ä–∏ —â–æ—Å—å ‚§µÔ∏è", reply_markup=reply_markup)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (
        "üíñ *–ü—Ä–∏–≤ –∫—É!* –Ø –•—ñ–Ω–∞-–ë–æ—Ç–∏–∫ ‚Äî —Ç–≤–æ—è –º º—è–∫–∞ —Ü–∏—Ñ—Ä–æ–≤–∞ –ø–æ–º—ñ—á–Ω–∏—Ü—è üå∏\n\n"
        "–Ø –≤–º—ñ—é:\n"
        "‚Ä¢ –í–µ—Å—Ç–∏ —Å–ø–∏—Å–æ–∫ —Å–ø—Ä–∞–≤: `/todo –∫—É–ø–∏—Ç–∏ —á–∞–π | –∑–∞–≤—Ç—Ä–∞`\n"
        "‚Ä¢ –ü–æ–∫–∞–∑–∞—Ç–∏ —Å–ø—Ä–∞–≤–∏: `/todo`, `/todo –∑–∞–≤—Ç—Ä–∞`, `/todo 2025-04-03`\n"
        "‚Ä¢ –í–∏–¥–∞–ª–∏—Ç–∏ —Å–ø—Ä–∞–≤—É: `/todo del 1`\n"
        "‚Ä¢ –í—ñ–¥–º—ñ—Ç–∏—Ç–∏ —è–∫ –≤–∏–∫–æ–Ω–∞–Ω–µ: `/done 1`\n"
        "‚Ä¢ –ù–∞–≥–∞–¥–∞—Ç–∏ –ø–æ–ø–∏—Ç–∏ –≤–æ–¥–∏: `/hydrate`\n\n"
        "üìã *–ö–æ–º–∞–Ω–¥–∏:*\n"
        "/start ‚Äî –∫–Ω–æ–ø–∫–∏\n"
        "/status ‚Äî —á–∏ –∂–∏–≤–∏–π —è\n"
        "/profile ‚Äî –ø—Ä–æ—Ñ—ñ–ª—å\n"
        "/todo ‚Äî —Å–ø–∏—Å–æ–∫ —Å–ø—Ä–∞–≤\n"
        "/done ‚Äî –≤–∏–∫–æ–Ω–∞–Ω–æ\n"
        "/hydrate ‚Äî –ø–∏—Ç–∏ –≤–æ–¥—É\n"
        "/help ‚Äî –¥–æ–≤—ñ–¥–∫–∞\n"
    )
    await update.message.reply_text(text, parse_mode="Markdown")

async def status(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("‚úÖ –Ø –∂–∏–≤–∏–π —ñ –º—É—Ä—á—É —Å—Ç–∞–±—ñ–ª—å–Ω–æ! üêæ")

async def profile(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user = get_user(user_id)
    if user:
        name = user.get("name", "(–Ω–µ –≤–∫–∞–∑–∞–Ω–æ)")
        gender = user.get("gender", "(–Ω–µ –≤–∫–∞–∑–∞–Ω–æ)")
        await update.message.reply_text(f"üë§ –ü—Ä–æ—Ñ—ñ–ª—å:\n–Ü–º'—è: {name}\n–°—Ç–∞—Ç—å: {gender}")
    else:
        await update.message.reply_text("–Ø —Ç–µ–±–µ —â–µ –Ω–µ –∑–Ω–∞—é üòø –ù–∞–ø–∏—à–∏ '–ó–∞–ø–∏—à–∏ –º–æ—î —ñ–º'—è'")

async def hydrate(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("üíß –ù–µ –∑–∞–±—É–¥—å –ø–æ–ø–∏—Ç–∏ –≤–æ–¥–∏—á–∫–∏, –º–æ—î —Å–µ—Ä–¥–µ–Ω—å–∫–æ!")

async def done(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user = get_user(user_id)
    if not user:
        await update.message.reply_text("–Ø —Ç–µ–±–µ —â–µ –Ω–µ –∑–Ω–∞—é üòø")
        return

    if len(context.args) < 1 or not context.args[0].isdigit():
        await update.message.reply_text("–í–∫–∞–∂–∏ –Ω–æ–º–µ—Ä –∑–∞–≤–¥–∞–Ω–Ω—è: /done 1")
        return

    index = int(context.args[0]) - 1
    todos = user.get("todo", [])

    if 0 <= index < len(todos):
        todos[index]["done"] = True
        db.update({"todo": todos}, User.id == user_id)
        await update.message.reply_text("‚úÖ –ó–∞–≤–¥–∞–Ω–Ω—è –≤–∏–∫–æ–Ω–∞–Ω–æ!")
    else:
        await update.message.reply_text("–ù–µ–≤—ñ—Ä–Ω–∏–π –Ω–æ–º–µ—Ä –∑–∞–≤–¥–∞–Ω–Ω—è üòø")

async def todo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user = get_user(user_id)
    if not user:
        save_user(user_id)
        user = get_user(user_id)

    if context.args and context.args[0] == "del" and len(context.args) > 1:
        index = int(context.args[1]) - 1
        if 0 <= index < len(user["todo"]):
            removed = user["todo"].pop(index)
            db.update({"todo": user["todo"]}, User.id == user_id)
            await update.message.reply_text(f"‚ùå –í–∏–¥–∞–ª–µ–Ω–æ: {removed['text']}")
        else:
            await update.message.reply_text("–ù–µ–≤—ñ—Ä–Ω–∏–π –Ω–æ–º–µ—Ä –∑–∞–≤–¥–∞–Ω–Ω—è üòø")
        return

    if context.args and not "|" in " ".join(context.args):
        date = parse_date(" ".join(context.args))
        if not date:
            await update.message.reply_text("–ù–µ–≤—ñ–¥–æ–º–∞ –¥–∞—Ç–∞. –ü—Ä–∏–∫–ª–∞–¥: /todo –∑–∞–≤—Ç—Ä–∞ –∞–±–æ /todo 2025-04-04")
            return
        tasks = [t for t in user["todo"] if t["due"] == date]
        if not tasks:
            await update.message.reply_text(f"–ù–∞ {date} —É —Ç–µ–±–µ –Ω—ñ—á–æ–≥–æ –Ω–µ–º–∞—î ‚ú®")
            return
        text = f"üìÖ –ó–∞–≤–¥–∞–Ω–Ω—è –Ω–∞ {date}:\n"
        for i, task in enumerate(tasks):
            checkbox = "[x]" if task["done"] else "[ ]"
            text += f"{i+1}. {checkbox} {task['text']}\n"
        await update.message.reply_text(text)
        return

    if context.args:
        full = " ".join(context.args)
        if "|" in full:
            parts = full.split("|", 1)
            task_text = parts[0].strip()
            due_date = parse_date(parts[1])
            if not due_date:
                await update.message.reply_text("–ù–µ–≤—ñ—Ä–Ω–∞ –¥–∞—Ç–∞. –ü—Ä–∏–∫–ª–∞–¥: /todo –∫—É–ø–∏—Ç–∏ —Ö–ª—ñ–± | –∑–∞–≤—Ç—Ä–∞")
                return
        else:
            task_text = full
            due_date = datetime.date.today().strftime("%Y-%m-%d")

        user["todo"].append({
            "text": task_text,
            "due": due_date,
            "done": False
        })
        db.update({"todo": user["todo"]}, User.id == user_id)
        await update.message.reply_text(f"‚ûï –î–æ–¥–∞–Ω–æ –Ω–∞ {due_date}: {task_text}")
    else:
        today = datetime.date.today().strftime("%Y-%m-%d")
        tasks = [t for t in user["todo"] if t["due"] == today]
        if not tasks:
            await update.message.reply_text("–°—å–æ–≥–æ–¥–Ω—ñ –≤ —Ç–µ–±–µ –Ω–µ–º–∞—î —Å–ø—Ä–∞–≤ ‚ú®")
            return
        text = f"üìã –°—å–æ–≥–æ–¥–Ω—ñ—à–Ω—ñ —Å–ø—Ä–∞–≤–∏:\n"
        for i, task in enumerate(tasks):
            checkbox = "[x]" if task["done"] else "[ ]"
            text += f"{i+1}. {checkbox} {task['text']}\n"
        await update.message.reply_text(text)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    text = update.message.text.strip()
    lower_text = text.lower()

    if user_id in waiting_for_name:
        save_user(user_id, name=text)
        waiting_for_name.remove(user_id)
        waiting_for_gender.add(user_id)
        await update.message.reply_text("–ê —Ç–∏ —Ö–ª–æ–ø–µ—Ü—å —á–∏ –¥—ñ–≤—á–∏–Ω–∞? üíôüíñ (–Ω–∞–ø–∏—à–∏ '—á–æ–ª–æ–≤—ñ–∫' –∞–±–æ '–∂—ñ–Ω–∫–∞')")
        return

    if user_id in waiting_for_gender:
        if "–∂" in lower_text:
            save_user(user_id, gender="–∂")
            waiting_for_gender.remove(user_id)
            await update.message.reply_text("–ó—Ä–æ–∑—É–º—ñ–ª–∞ üå∏ –¢–µ–ø–µ—Ä —è —Ç–µ–±–µ –ø–∞–º º—è—Ç–∞—é!")
        elif "—á" in lower_text:
            save_user(user_id, gender="—á")
            waiting_for_gender.remove(user_id)
            await update.message.reply_text("–ó—Ä–æ–∑—É–º—ñ–≤ üíô –¢–µ–ø–µ—Ä —è —Ç–µ–±–µ –ø–∞–º º—è—Ç–∞—é!")
        else:
            await update.message.reply_text("–ù–∞–ø–∏—à–∏, –±—É–¥—å –ª–∞—Å–∫–∞, '–∂—ñ–Ω–∫–∞' –∞–±–æ '—á–æ–ª–æ–≤—ñ–∫' üåº")
        return

    user = get_user(user_id)
    name = user["name"] if user else None
    gender = user["gender"] if user else None
    short = gendered(name, gender)

    if not name:
        waiting_for_name.add(user_id)
        await update.message.reply_text("–ü—Ä–∏–≤ –∫—É, —è —Ç–µ–±–µ —â–µ –Ω–µ –∑–Ω–∞—é! –Ø–∫ —Ç–µ–±–µ –Ω–∞–∑–∏–≤–∞—Ç–∏? üí¨")
        return

    if "–æ–±—ñ–π–º–∏" in lower_text:
        await update.message.reply_text(f"–î–æ–±—Ä–µ, {short}, –ª–æ–≤–∏–∏–∏ –æ–±—ñ–π–º–∏! ü§ó")
    elif "—Å–∫–∞–∂–∏" in lower_text:
        await update.message.reply_text(f"–¢–∏ {gendered_phrase(gender, '—á—É–¥–æ–≤–∞', '—á—É–¥–æ–≤–∏–π')}, {short}. –Ø –∑–∞–≤–∂–¥–∏ –ø–æ—Ä—É—á üíó")
    elif "—á–∞—Å" in lower_text or "–≥–æ–¥–∏–Ω–∞" in lower_text:
        kyiv_time = datetime.datetime.now(pytz.timezone("Europe/Kyiv")).strftime("%H:%M")
        await update.message.reply_text(f"{short}, –∑–∞—Ä–∞–∑ –≤ –£–∫—Ä–∞—ó–Ω—ñ: {kyiv_time} üïê")
    elif "–∫–æ—Ç–∏–∫" in lower_text:
        await update.message.reply_animation("https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif")
    elif "–∑–∞–ø–∏—à–∏" in lower_text or "—ñ–º'—è" in lower_text:
        waiting_for_name.add(user_id)
        await update.message.reply_text("–ù–∞–ø–∏—à–∏, —è–∫ —Ç–µ–±–µ –Ω–∞–∑–∏–≤–∞—Ç–∏ üí¨")
    else:
        await update.message.reply_text(f"–ú—É—Ä? –Ø —â–µ –Ω–µ –∑–Ω–∞—é —Ü—ñ —Å–ª–æ–≤–∞, {short} ü•∫")

def morning_reminder():
    users = db.all()
    today = datetime.date.today().strftime("%Y-%m-%d")
    for user in users:
        tasks = [t for t in user.get("todo", []) if t["due"] == today and not t["done"]]
        if tasks:
            app.bot.send_message(chat_id=user["id"], text="üåû –î–æ–±—Ä–∏–π —Ä–∞–Ω–æ–∫! –û—Å—å —Ç–≤–æ—ó —Å–ø—Ä–∞–≤–∏ –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ:")
            for i, task in enumerate(tasks):
                app.bot.send_message(chat_id=user["id"], text=f"{i+1}. {task['text']}")

app = ApplicationBuilder().token(TOKEN).build()
app.add_handler(CommandHandler("start", start))
app.add_handler(CommandHandler("help", help_command))
app.add_handler(CommandHandler("status", status))
app.add_handler(CommandHandler("profile", profile))
app.add_handler(CommandHandler("hydrate", hydrate))
app.add_handler(CommandHandler("done", done))
app.add_handler(CommandHandler("todo", todo))
app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_message))

scheduler = BackgroundScheduler(timezone="Europe/Kyiv")
scheduler.add_job(morning_reminder, "cron", hour=9, minute=0)
scheduler.start()

print("‚ú® –•—ñ–Ω–∞-–ë–æ—Ç–∏–∫ –∑–∞–ø—É—â–µ–Ω–æ –∑ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª–æ–º –¥–µ–¥–ª–∞–π–Ω—ñ–≤, –Ω–∞–≥–∞–¥—É–≤–∞–Ω—å —ñ –¥–∞—Ç üóì")
app.run_polling()